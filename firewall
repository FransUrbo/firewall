#!/bin/sh

# $Id: firewall,v 1.23 2005-12-17 20:21:15 turbo Exp $
#DEBUG='echo'

if [ ! -f /etc/firewall.conf ]; then
    # The config file don't exists, load this script with default values...
    echo -n "Loading default firewall values... "

    # Where is the iptables, rmmod and modprobe binaries?
    IPTABLES=/sbin/iptables
    RMMOD="/sbin/rmmod"
    MODPROBE="/sbin/modprobe"
    #
    # External ethernet device
    EXTERNAL_ETH=eth0
    #
    # If defined, see 'ALLOW' below for ports to allow on local network
    # - 'size' of network. 24 => a C-Net
    EXTERNAL_NET=24
    
    # ----- PORTS TO BLOCK ----
    # ':' is a range... So ':19' means '0 to 19'...
    PORTS=":19"				# Block: 0-19
    PORTS="$PORTS 26:52"		# Open:  ssh, telnet, smtp
    PORTS="$PORTS 54:79"		# Open:  domain
    PORTS="$PORTS 81:87"		# Open:  http
    PORTS="$PORTS 89:109"		# Open:  kerberos, pop3
    PORTS="$PORTS 111"			# Close: SunRPC
    PORTS="$PORTS 115:142"		# Open:  Auth, SFTP
    PORTS="$PORTS 144:388"		# Open:  ldap
    PORTS="$PORTS 390:442"		# Open:  imap2
    PORTS="$PORTS 444:635"		# Open:  https
    PORTS="$PORTS 637:992"		# Open:  ldaps
    PORTS="$PORTS 994"			# Open:  imaps
    PORTS="$PORTS 996:1023"		# Open:  pop3s
    PORTS="$PORTS 1061 1214 1832"	# Block: Crappy filesharing protocols
    PORTS="$PORTS 3306"			# Block: mysql
    PORTS="$PORTS 6000"			# Block: X11
    
    # ----- PORTS TO ALLOW ON LOCAL NET -----
    ALLOW="137:139"			# SMB/Samba
    ALLOW="$ALLOW 2988"			# AFbackup system
    
    echo "done."
else
    # Load the config file...
    echo -n "  Loading the firewall config file... "
    . /etc/firewall.conf
    echo "done."
fi


# -------
# DONE WITH LOCAL CONFIGURATIONS. DON'T CHANGE ANYTHING BELOW!
# -------

modprobe () {
    module=$1

    MODPROBE=`echo $MODPROBE | sed 's@\ .*@@'`
    $MODPROBE $module > /dev/null 2>&1
}

get_net () {
    string=$1

    set -- `echo $string | sed 's@/@ @g'`
    iface=$1 ; ip=$2 ; nmask=$3
    NET=`netmask $ip/$nmask`
}

debug () {
    string="$*"

    if [ ! -z "$DEBUG" ]; then
	string="`echo $string | sed 's@\"@\\\"@'`"

	echo -n "  "
	$DEBUG $string
    else
	$string
    fi
}

# --------------------------------
# Output the error message, and exit with error code
error () {
    code=$1
    shift
    msg=$*

    echo $msg
    exit $code
}

# --------------------------------
# Find the IP address on the external interface
get_ip () {
    # Get the external IP address
    set -- `ifconfig $EXTERNAL_ETH | grep inet`; shift
    EXTERNAL_IP=`echo $1 | sed 's@addr:@@'`

    if [ ! -z "$EXTERNAL_NET" ]; then
	EXTERNAL_NET="$EXTERNAL_IP/$EXTERNAL_NET"
    else
	# Got to have SOME default (othervise iptables
	# complain about faulty netmask '').
	EXTERNAL_NET="$EXTERNAL_IP/24"
    fi

    # Get the internal IP address
    if [ "$INTERNAL_ETH" != "" ]; then
	for eth in $INTERNAL_ETH; do
	    iface=`echo $eth | sed 's@/.*@@'`

	    set -- `ifconfig $iface | grep inet`; shift
	    ip=`echo $1 | sed 's@addr:@@'`
	    mask=`echo $3 | sed 's@Mask:@@'`

	    INTERNAL_IP="$INTERNAL_IP $eth/$ip/$mask"
	    
#	    if echo $INTERNAL_ETH | grep -q ':'; then
#		# It's an alias!
#		INTERNAL_ETH=`echo $INTERNAL_ETH | sed 's@:.*@@'`
#	    fi
	done
    fi

    # Return ok if we have an external IP, and the internal IP is found
    # If we haven't specified a internal ethernet interface, ignore the
    # unavilible internal IP...
    if [ "$EXTERNAL_IP" == "" -o "$INTERNAL_IP" == "" ]; then
        return 0
    fi

    # We have failed to obtain the IP addresses!
    return 1
}

# --------------------------------
# This is the main logic. Add/Remove the firewall rules we specify in the
# config file
chains_external () {
    cmd=$1

    if [ "$cmd" = "add" ]; then
        CHAIN="-A INPUT "
	ECHO="  Setting up"
    else
        CHAIN="-D INPUT "
	ECHO="  Removing"
    fi
    CHAIN="$IPTABLES $CHAIN"

    # -------------
    # Some local exeptions
    if [ "$EXTERNAL_NET" != "" -a "$ALLOW" != "" ]; then
	echo -n "$ECHO local accepts: " ; [ ! -z "$DEBUG" ] && echo

	for port in $ALLOW; do
	    echo -n "$port " ; 	[ ! -z "$DEBUG" ] && echo
	    if [ "$EXTERNAL_NET" != "" ]; then
		debug $CHAIN -i $EXTERNAL_ETH -s $EXTERNAL_NET -d $EXTERNAL_IP -j ACCEPT --protocol tcp --dport $port
		debug $CHAIN -i $EXTERNAL_ETH -s $EXTERNAL_NET -d $EXTERNAL_IP -j ACCEPT --protocol udp --dport $port
	    fi
	done
	echo " done."
    fi
    [ ! -z "$DEBUG" ] && echo

    # -------------
    # Setting up accepts on PORT to/from our local network
    if [ "$INTERNAL_IP" != "" ]; then
	for eth in $INTERNAL_IP; do
	    get_net $eth

	    echo -n "$ECHO accept to/from the internal network ($iface): " ; [ ! -z "$DEBUG" ] && echo

	    for port in $PORTS; do
		echo -n "$port " ; [ ! -z "$DEBUG" ] && echo

		debug $CHAIN -s $NET -d $ip -j ACCEPT --protocol tcp --dport $port
		debug $CHAIN -s $NET -d $ip -j ACCEPT --protocol udp --dport $port
	    done
	    echo
	done
    fi

    # -------------
    # Special circumstances - friendly hosts outside the external network
    if [ ! -z "$FRIENDLY" ]; then
	echo -n "$ECHO friendly hosts: " ; [ ! -z "$DEBUG" ] && echo

	for friend in $FRIENDLY; do
	    echo -n "$friend " ; [ ! -z "$DEBUG" ] && echo

	    set -- `echo $friend | sed 's@:@ @g'` ; host=$1 ; port=$2
	    [ ! -z "$port" ] && port="--dport $port"

	    debug $CHAIN -i $EXTERNAL_ETH -s $host -d $EXTERNAL_IP -j ACCEPT --protocol tcp $port
	    debug $CHAIN -i $EXTERNAL_ETH -s $host -d $EXTERNAL_IP -j ACCEPT --protocol udp $port
	done
	echo
    fi

    # -------------
    # Setup the brute force attempt checks/blocks
    if [ ! -z "$BRUTE_RULE" ]; then
	echo -n "$ECHO brute force limits: " ; [ ! -z "$DEBUG" ] && echo

	if [ ! -z "$BRUTE_LIMIT" ]; then
	    set -- `echo $BRUTE_LIMIT | sed -e 's@ .*@@g' -e 's@:@ @'` ; attempts=$1 ; within=$2
	else
	    attempts=4 ; within=60
	fi

	# -------------
	# Setup connection attempts limits
	for brute in $BRUTE_RULE; do
	    echo -n "$brute " ; [ ! -z "$DEBUG" ] && echo
	    
	    set -- `echo $brute | sed 's@:@ @g'` ; port=$1 ; name=$2
	    list="$name"_WHITELIST ; logprefix="$name"_brute_force
	    
	    # Setup the whitelist jump table
	    if [ "$cmd" = "add" ]; then
		debug $IPTABLES -N $list
	    fi
	    
	    debug $CHAIN -p tcp --dport $port -m state --state NEW -m recent --set --name $name
	    debug $CHAIN -p tcp --dport $port -m state --state NEW -j $list
	    debug $CHAIN -p tcp --dport $port -m state --state NEW -m recent --update \
		--seconds $within --hitcount $attempts --rttl --name $name -j LOG \
		--log-prefix $logprefix
	    debug $CHAIN -p tcp --dport $port -m state --state NEW -m recent --update \
		--seconds $within --hitcount $attempts --rttl --name $name -j DROP
	done
	echo

	# -------------
	# Add friendly host(s) to brute force whitelists
	if [ ! -z "$FRIENDLY" ]; then
	    for brute in $BRUTE_RULE; do
		set -- `echo $brute | sed 's@:@ @g'` ; port=$1 ; name=$2
		list="$name"_WHITELIST
		
		echo -n "$ECHO $name whitelisting: " ; [ ! -z "$DEBUG" ] && echo
		
		for friend in 127.0.0.1 $EXTERNAL_IP $FRIENDLY; do
		    set -- `echo $friend | sed 's@:@ @g'` ; host=$1
		    echo -n "$host " ; [ ! -z "$DEBUG" ] && echo
		    
		    if [ "$cmd" = "add" ]; then
			debug $IPTABLES -A $list -s $host -d $EXTERNAL_IP -j ACCEPT -m recent --remove --name $name
		    else
			debug $IPTABLES -D $list -s $host -d $EXTERNAL_IP -j ACCEPT -m recent --remove --name $name
		    fi
		done
		echo
	    done
	fi

	# -------------
	if [ "$cmd" = "del" ]; then
	    # Remove the whitelist jump table(s)
	    echo -n "  Remove the whitelist jump table(s): "

	    for brute in $BRUTE_RULE; do
		echo -n "$brute " ; [ ! -z "$DEBUG" ] && echo
		
		set -- `echo $brute | sed 's@:@ @g'` ; port=$1 ; name=$2
		list="$name"_WHITELIST ; logprefix="$name"_brute_force
		
		debug $IPTABLES -X $list
	    done
	    echo
	fi
    fi

    # -------------
    # Setting up TCP rejects
    echo -n "$ECHO TCP rejects on external IP: " ; [ ! -z "$DEBUG" ] && echo
    for port in $PORTS; do
	echo -n "$port " ; [ ! -z "$DEBUG" ] && echo
	debug $CHAIN -i $EXTERNAL_ETH -s 0/0 -d $EXTERNAL_IP -j REJECT --reject-with tcp-reset --protocol tcp --dport $port
    done
    echo

    # -------------
    # Setting up UDP rejects
    echo -n "$ECHO UDP rejects on external IP: " ; [ ! -z "$DEBUG" ] && echo
    for port in $PORTS; do
	echo -n "$port " ; [ ! -z "$DEBUG" ] && echo
	debug $CHAIN -i $EXTERNAL_ETH -s 0/0 -d $EXTERNAL_IP -j DROP  --protocol udp --dport $port
    done
    echo
}

# --------------------------------
chains_internal () {
    cmd=$1

    # Setup iptables command
    CHAIN="$IPTABLES -t nat"
    if [ "$cmd" = "add" ]; then
        CHAIN="$CHAIN -A PREROUTING "
	ECHO="  Setting up"
    else
        CHAIN="$CHAIN -D PREROUTING "
	ECHO="  Removing"
    fi

    # -------------
    # Do portforwarding of internal traffic
    if [ "$PORTS_FW" != "" ]; then
	echo -n "$ECHO external port: " ; [ ! -z "$DEBUG" ] && echo
	
	for entry in $PORTS_FW; do
	    set -- `echo $entry | sed 's@:@ @g'`
	    echo -n "$1->$2:$3 " ; [ ! -z "$DEBUG" ] && echo
	    debug $CHAIN -p tcp -d $EXTERNAL_IP --dport $1 -j DNAT --to $2:$3
	    
	    if grep -q $1/udp /etc/services; then
		# There's a UDP entry for this port. Better to forward that to...
		debug $CHAIN -p udp -d $EXTERNAL_IP --dport $1 -j DNAT --to $2:$3
	    fi
	done
	echo ""
    fi
    
    # -------------
    # Masquerade internal traffic
    if [ "$INTERNAL_IP" != "" ]; then
	if [ -z "$DEBUG" ]; then
	    if [ "$cmd" = "add" ]; then
		echo 1 > /proc/sys/net/ipv4/ip_forward 
		modprobe ip_nat_ftp
		modprobe ip_nat_irc
	    else
		echo 0 > /proc/sys/net/ipv4/ip_forward 
	    fi
	fi
	
	echo -n "$ECHO masquerading on: " ; [ ! -z "$DEBUG" ] && echo
	for eth in $INTERNAL_IP; do
	    echo -n "$iface "
	    get_net $eth
	    
	    if [ "$cmd" = "add" ]; then
		debug $IPTABLES -t nat -A POSTROUTING -s $NET -d 0/0 -j MASQUERADE
	    else
		debug $IPTABLES -t nat -D POSTROUTING -s $NET -d 0/0 -j MASQUERADE
	    fi
	done
	echo ""
    fi

    # -------------
    # Setup PPTP VPN connections
    if [ "$PPTP_SERVER" != "" -a "$PPTP_CLIENT" != "" ]; then
	echo -n "$ECHO VPN masquerading $PPTP_CLIENT to $PPTP_SERVER: " ; [ ! -z "$DEBUG" ] && echo
	
	[ -z "$DEBUG" ] && modprobe ip_nat_pptp
	debug $CHAIN -p tcp --dport 1723 -j DNAT --top $PPTP_CLIENT
	debug $CHAIN -p 47 -j DNAT --top $PPTP_CLIENT
	
	echo "done."
    fi

    # -------------
    # Enable the transparent proxy (force all connection through the proxy)
    if [ ! -z "$TRANS_PROXY" -a "$TRANS_PROXY" != "0" ]; then
	echo -n "$ECHO transparent proxy: " ; [ ! -z "$DEBUG" ] && echo
	
	if [ "$INTERNAL_IP" != "" ]; then
	    for eth in $INTERNAL_IP; do
		get_net $eth
		
		debug $CHAIN -s $NET -d 0/0 --protocol tcp --destination-port 80 -j REDIRECT --to-ports $TRANS_PROXY
		echo "done."
	    done
	fi
    fi
}

# --------------------------------
# Make sure we have the binaries...
if [ ! -x `echo $IPTABLES | sed 's@\ .*@@'` -o ! -x `echo $RMMOD | sed 's@\ .*@@'` -o ! -x `echo $MODPROBE | sed 's@\ .*@@'` ]; then
    echo "Some (or all) executables don't exists or isn't executable..."
    exit 1
fi

# --------------------------------
# Are we running a iptables enabled kernel!?
if [ -f "/proc/ksyms" ]; then
    ksyms=/proc/ksyms
elif [ -f "/proc/kallsyms" ]; then
    ksyms=/proc/kallsyms
else
    echo 'No /proc/{ksyms,kallsyms} file!?'
    exit 1
fi
    
if ! cat $ksyms | grep -q ip_tables; then
    # Module not loaded, or no support for ip tables...

    if [ ! -f "/lib/modules/`uname -r`/kernel/net/ipv4/netfilter/ip_tables.o" \
      -a ! -f "/lib/modules/`uname -r`/kernel/net/ipv4/netfilter/ip_tables.ko" ]
    then
	echo "You're not running a iptables enabled kernel!"
	exit 2
    else
	modprobe ip_tables
    fi
fi

#####################################
#                                   #
# M A I N  P R O G R A M  B E L O W #
#                                   #
#####################################

# Get the required IP addresses (internal/external)
get_ip && error 1 "Error in getting IP address(es)..."

case "$1" in
    start)
	# Setup TCP/UDP rejects and accepts on the external interface
	chains_external add

	# Setup portforwarding etc on the internal interface
	chains_internal add

	# -------------
	# Execute local scripts
	if [ -x "$0.local" -a -z "$DEBUG" ]; then
	    $0.local start
	fi

	# -------------
	# Block specific hosts. Probably spammers/portscanners...
	if [ -f "/etc/firewall.block.conf" -a -x "/usr/local/sbin/reject_ip" -a -z "$DEBUG" ]; then
	    /usr/local/sbin/reject_ip add
	fi
	;;

    stop)
	# Remove the TCP/UDP rejects and accepts
	chains_external del

	# Remove portforwarding etc on the internal interface
	chains_internal del

	echo -n "  Unloading modules: " ; [ ! -z "$DEBUG" ] && echo
	for module in "ip_nat_ftp ip_conntrack_ftp ip_nat_irc ip_conntrack_irc ip_nat_pptp ip_conntrack_pptp ipt_MASQUERADE iptable_nat ip_conntrack ipt_REJECT iptable_filter ip_tables"; do
	    echo -n "$module " ; [ ! -z "$DEBUG" ] && echo
	    [ -z "$DEBUG" ] && $RMMOD $module > /dev/null 2>&1
	done
	echo

	# -------------
	# Execute local scripts
	if [ -x "$0.local" -a -z "$DEBUG" ]; then
	    $0.local stop
	fi
	;;

    flush)
	echo -n "  Flushing firewall rules... " ; [ ! -z "$DEBUG" ] && echo
	debug $IPTABLES -F
	debug $IPTABLES -F -t nat

	for chain in `iptables -L -n | grep ^Chain | sed -e 's@^Chain @@' -e 's@ .*@@' | egrep -v 'INPUT|FORWARD|OUTPUT'`; do
	    debug $IPTABLES -X $chain
	done

	# TODO: Clean the '*_WHITELIST's    (?)
	# TODO: Clean the '-m recent' rules (?)
	echo "done."
	;;

    *)
	echo "Usage: $0 {start|stop}" >&2
	;;
esac
exit 0

# $Log: firewall,v $
# Revision 1.23  2005-12-17 20:21:15  turbo
# * Function to load modules so we can redirect STDOUT/STDERR to /dev/null
#   correctly.
# * Function get_net() added which extracts the network/netmask from an
#   INTERNAL_IP variable portion. Defined as 'interface/ipaddress/netmask'.
# * Function debug() added which 'prettifies' the debug output.
# * Support multiple internal network interfaces - go through each internal
#   interface and add whatever rules specified on ALL of them.
# * Rename the chains() function to chains_external() which is more in line
#   what the function does - adds rules to the EXTERNAL interface (only!).
#   - Prettify the debug output using both debug() and echo at the right place(s).
#   - Add support for DELETING the Brute Force rules.
#   - Remove the 'whitelist jump table(s)' (AFTER the brute force rules have
#     been cleared from the jump table(s)) when stop'ing the firewall.
# * Move the stuff that sets up (and removes) the rules on the INTERNAL interface
#   to it's own function - chains_internal().
#   - Same changes as done to the chains_external() function...
# * Support kernel version > 2.6, which module is suffixed with '.ko' instead
#   of '.o'.
#
# Revision 1.22  2005/06/05 09:24:19  turbo
# * Translate an ethernet alias (remove the ':.*' part) so that iptables
#   won't complain.
# * Always (!) add localhost and the external IP (?) to the connection
#   limit whitelist(s).
#
# Revision 1.21  2005/06/04 14:06:46  turbo
# Support Linux kernel version 2.6. In 2.6 the proc file is 'kallsyms', in
# 2.4 it's 'ksyms'...
#
# Revision 1.20  2005/06/04 13:57:12  turbo
# * Support debugging - echo the command instead of executing them
#   - Don't execute the local script if debugging...
# * If there is no network mask (/24, /32 etc), then default to '/24'.
#   This so that 'iptables' won't fail...
# * Support friendly hosts without port - allow ALL connection(s) from these
#   host(s).
# * Support connection attempt limits by ignoring host if it tries to connect
#   for more than x times in y seconds...
#   - Friendly host(s) is put in a whitelist.
# * When flushing rules, _remove_ ALL chains (exept INPUT, FORWARD and OUTPUT).
#
# Revision 1.19  2005/04/09 09:35:15  turbo
# If there's an UDP entry for the port that's being forwarded, we need to do
# a portforward on the UDP protocol in addition to the TCP proto...
#
# Revision 1.18  2003/10/31 09:13:32  turbo
# Missing ] in 'if then fi'...
#
# Revision 1.17  2003/10/31 09:01:57  turbo
# Possibility to add 'friendly hosts'. That is, hosts that should be exepted
# (on a port basis) from the ordinary block/reject rules..
# Example: From work I'd like to connect to NTop. Naturally, this port should
#          be absolutly hidden for the rest of the world. I don't even want my
#          home network access!!
#
# Revision 1.16  2002/09/07 14:09:42  turbo
# Unload the modules in the correct order. Can't remove
# ipt_REJECT before the iptable_nat (etc)..
#
# Revision 1.15  2002/06/25 09:00:48  turbo
# * Don't output 'done.' when removing/setting up UDP/TCP rejects etc.
#   Just '.' and newline. Looks better.
# * Make sure that TRANS_PROXY don't contain '0' (which would mean that
#   we want to disable this feature).
# * Remove some more module (ipt_MASQUERADE, ipt_REJECT, iptable_filter)
#   BEFORE removing iptable_nat etc. Dependencies...
#
# Revision 1.14  2002/06/25 08:37:06  turbo
# * We can't send STD{OUT,ERR} to /dev/null. For some reason
#   the commandline think it's a module to remove. I'll look into
#   that some other time...
# * Output the correct lead text if removing/setting up firewall,
#   by using different ECHO variable content.
# * Don't output a newline if removing portforwarding (lead text).
#
# Revision 1.13  2002/03/04 12:07:49  turbo
# If we have the file /etc/firewall.block.conf AND /usr/local/sbin/reject_ip is executable, block certain hosts (spammers and/or portscanners probably)
#
# Revision 1.12  2002/03/04 11:24:22  turbo
# Added the transparent proxy support. The variable TRANS_PROXY is the
# proxy port...
# Removed the template TRANS_PROXY, it's specified in the config file...
#
# Revision 1.11  2002/03/03 23:06:51  turbo
# * Only setup the local accepts if the variable ALLOW is non-null.
# * Output the ports we're doing local accept on.
# * Be more clear about the rejects entries (... on external/internal IP).
# * Uncomment the iptables entries for PPTP server masquerading.
#   The 'if/fi' block failed othervise...
#
# Revision 1.10  2002/03/03 21:34:53  turbo
# Remove the ip_conntrack_pptp as well when disabling masquerading.
#
# Revision 1.9  2002/03/03 21:27:34  turbo
# * Since we added a redirect of stdout and stderr, we must filter out everything
#   after the first space when checking for executable binary...
# * Stray 'c' character after the get_ip() call.
#
# Revision 1.8  2002/03/03 21:17:07  turbo
# * Send all output from rmmod/modprobe to /dev/null.
# * Load the ip_nat_irc module if forwarding/masquerading.
# * If masquerading to a PPTP server, load the ip_nat_pptp module, not
#   iptable_nat.
# * Remove the modules in right order. ip_nat* first, then the ip_conntrack*.
#   Do this in a for loop.
#
# Revision 1.7  2002/03/03 21:05:13  turbo
# We might have ip tables as a module, so if we don't have the support in
# the kernel (/proc/ksyms), we check to see if we have the actual module
# (in /lib/modules/KERNELVER/kernel/net/ipv4/netfilter).
#
# Revision 1.6  2002/03/03 19:27:28  turbo
# Add the variable to the variable. The last line overwrote the previous!
#
# Revision 1.5  2002/03/03 19:22:51  turbo
# Removed the undefined defaults. They are specified in the config file...
#
# Revision 1.4  2002/03/03 19:09:20  turbo
# * Check to see if the local firewall setup script is EXECUTABLE, not EXISTING.
# * More comment lines before major executions
# * Run the local script when stopping firewall as well
#
# Revision 1.3  2002/03/03 18:55:11  turbo
# * Added some comment lines before each major command to distinguish them
# * We're only modifying the INPUT chain in the chains() function, so include
#   that into the short hand ($CHAIN) at the top (so we can improve easily on
#   the function).
# * Make sure we call get_ip() wheter we're called with start or stop...
# * Put the execution of the local script at the end (after setting up
#   transparent proxy).
#
# Revision 1.2  2002/03/03 18:09:16  turbo
# * Pretty output when loading default/config file
# * Created an error() function that outputs an error message and exits with
#   specified error code.
# * Added CVS keywords Id and Log.
#
